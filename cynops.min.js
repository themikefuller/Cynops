"use strict";function Cynops(cryptic){if(!cryptic)throw"An instance of Starbase Cryptic is require.";async function createCard(user){return cloneState({idk:user.idk.pub,spk:user.spk.pub})}async function sessionHash(combinedDH,init){let hashed=await cryptic.hkdf(combinedDH,new Uint8Array(32),cryptic.fromText("SIGNAL"),768),sharedKey=cryptic.decode(hashed).slice(0,32),authKey=cryptic.decode(hashed).slice(32,64),sessionId=cryptic.decode(hashed).slice(64,96),ad=cryptic.combine(cryptic.decode(init.from),cryptic.decode(init.to)),AD=await cryptic.hkdf(cryptic.combine(authKey,ad),new Uint8Array(32),cryptic.fromText("AD"),256);return{sessionId:cryptic.encode(sessionId),sk:cryptic.encode(sharedKey),AD:AD,init:init}}async function rootKDF(rk,dh){let ratchet=await cryptic.hkdf(cryptic.decode(dh),cryptic.decode(rk),cryptic.fromText("ROOT"),512);return[cryptic.encode(cryptic.decode(ratchet).slice(0,32)),cryptic.encode(cryptic.decode(ratchet).slice(32))]}async function chainKDF(ck){let mk=await cryptic.hmacSign(cryptic.decode(ck),"");return[await cryptic.hmacSign(cryptic.decode(ck),""),mk]}async function skipMessageKeys(state,until,maxSkip){if(state.Nr+maxSkip<until)return Promise.reject({message:"Too many skipped messages!"});if(state.CKr)for(;state.Nr<until;){let mk=null;[state.CKr,mk]=await chainKDF(state.CKr),state.MKSKIPPED[state.DHr]||(state.MKSKIPPED[state.DHr]={}),state.MKSKIPPED[state.DHr][state.Nr]=mk,state.Nr+=1}}async function ratchetDecrypt(state,msgPayload={},AD,maxSkip=10){let{header:header,ciphertext:ciphertext}=msgPayload,AEAD=await cryptic.hkdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),found=await async function(state,header,ciphertext,AEAD){if(state.MKSKIPPED[header.dh]&&state.MKSKIPPED[header.dh][header.n]){let mk=state.MKSKIPPED[header.dh][header.n],KEY=await cryptic.hkdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(KEY),cryptic.decode(AEAD)).catch(err=>null);return plaintext?(delete state.MKSKIPPED[header.dh][header.n],{header:header,plaintext:plaintext}):null}}(state,header,ciphertext,AEAD||null);if(found)return found;header.dh!==state.DHr&&(await skipMessageKeys(state,header.pn,maxSkip),await async function(state,header){state.PN=state.Ns,state.Ns=0,state.Nr=0,state.DHr=header.dh;let dh1=await cryptic.ecdh(state.DHs.key,state.DHr);[state.RK,state.CKr]=await rootKDF(state.RK,dh1),state.DHs=await cryptic.createECDH();let dh2=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(state.RK,dh2),!0}(state,header)),await skipMessageKeys(state,header.n,maxSkip);let mk=null;[state.CKr,mk]=await chainKDF(state.CKr),state.Nr+=1;let KEY=await cryptic.hkdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),plaintext=await cryptic.decrypt(ciphertext,cryptic.decode(KEY),cryptic.decode(AEAD)).catch(err=>{throw{error:"failed to decrypt"}});return delete state.init,{header:header,plaintext:JSON.parse(plaintext)}}function cloneState(src){let target={};if("string"==typeof src)return target=src.toString();src instanceof Array&&(target=[]);for(let prop in src)src[prop]&&"object"==typeof src[prop]?target[prop]=cloneState(src[prop]):target[prop]=src[prop];return target}function Session(sessionData){let sessionState=cloneState(sessionData),session={to:()=>cloneState(sessionData).user};return session.send=(async message=>{let state=cloneState(sessionState.state),payload=await async function(state,msg,AD,init){let mk=null;[state.CKs,mk]=await chainKDF(state.CKs);let header={dh:state.DHs.pub,pn:state.PN,n:state.Ns};state.Ns+=1;let AEAD=await cryptic.hkdf(cryptic.combine(cryptic.decode(AD),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("AEAD"),256),KEY=await cryptic.hkdf(cryptic.combine(cryptic.decode(mk),cryptic.fromText(JSON.stringify(header))),new Uint8Array(32),cryptic.fromText("ENCRYPT"),256),encrypted={header:header,ciphertext:await cryptic.encrypt(JSON.stringify(msg),cryptic.decode(KEY),cryptic.decode(AEAD))};return init&&(encrypted.init=cloneState(init)),encrypted}(state,message,sessionState.AD||null,sessionState.init||null);return payload.to=sessionData.user.toString(),sessionState.state=cloneState(state),payload}),session.read=(async payload=>{let state=cloneState(sessionState.state),decrypted=await ratchetDecrypt(state,payload,sessionState.AD||null);sessionState.init&&delete sessionState.init;let msg={header:payload.header,plaintext:decrypted.plaintext,from:session.to()};return sessionState.state=cloneState(state),msg}),session.save=(()=>{let backup={state:cloneState(sessionState.state)};return sessionState.sessionId&&(backup.sessionId=cloneState(sessionState.sessionId)),sessionState.init&&(backup.init=cloneState(sessionState.init)),sessionState.user&&(backup.user=cloneState(sessionState.user)),sessionState.AD&&(backup.AD=cloneState(sessionState.AD)),backup}),session}function User(userData){let userState=cloneState(userData),user={},useUser=()=>userState;return user.getCard=(async(includeOPK=!1)=>{let card=cloneState(userState.card);if(includeOPK){let opk=await cryptic.createECDH();userState.opks[opk.pub]=opk.key,card.opk=opk.pub.toString()}return card}),user.updateSPK=(async()=>{let spk=await async function(user){return await cryptic.createECDH()}();return userState.spk=spk,userState.card=await createCard(userState),!0}),user.sealEnvelope=(async(to,msg)=>(async function(userIDK,to,message){let idk=userIDK.pub,env={},epk=await cryptic.createECDH(),dh1=await cryptic.ecdh(epk.key,to),envSalt=cryptic.combine(cryptic.decode(to),cryptic.decode(epk.pub)),envBits=await cryptic.hkdf(cryptic.decode(dh1),envSalt,cryptic.fromText("ENVELOPE"),768),envAD=cryptic.combine(cryptic.decode(envBits).slice(0,32),cryptic.combine(cryptic.decode(epk.pub),cryptic.decode(to))),envKey=cryptic.decode(envBits).slice(32,64),envChain=cryptic.decode(envBits).slice(64,96),sealed=await cryptic.encrypt(idk,envKey,envAD),dh2=await cryptic.ecdh(userIDK.key,to),sealSalt=cryptic.combine(envChain,cryptic.fromText(sealed)),sealBits=await cryptic.hkdf(cryptic.decode(dh2),cryptic.combine(sealSalt,cryptic.decode(idk)),cryptic.fromText("SEAL"),512),sealAD=cryptic.combine(cryptic.decode(sealBits).slice(0,32),cryptic.decode(to)),sealKey=cryptic.decode(sealBits).slice(32,64);return env.to=to,env.epk=epk.pub,env.seal=sealed,env.ciphertext=await cryptic.encrypt(JSON.stringify(message),sealKey,sealAD),env})(useUser().idk,to,msg)),user.openEnvelope=(async env=>(async function(userIDK,env){let idk=userIDK.pub,epk=env.epk,dh1=await cryptic.ecdh(userIDK.key,epk),envSalt=cryptic.combine(cryptic.decode(idk),cryptic.decode(epk)),envBits=await cryptic.hkdf(cryptic.decode(dh1),envSalt,cryptic.fromText("ENVELOPE"),768),envAD=cryptic.combine(cryptic.decode(envBits).slice(0,32),cryptic.combine(cryptic.decode(epk),cryptic.decode(idk))),envKey=cryptic.decode(envBits).slice(32,64),envChain=cryptic.decode(envBits).slice(64,96),from=await cryptic.decrypt(env.seal,envKey,envAD),dh2=await cryptic.ecdh(userIDK.key,from),sealSalt=cryptic.combine(envChain,cryptic.fromText(env.seal)),sealBits=await cryptic.hkdf(cryptic.decode(dh2),cryptic.combine(sealSalt,cryptic.decode(from)),cryptic.fromText("SEAL"),512),sealAD=cryptic.combine(cryptic.decode(sealBits).slice(0,32),cryptic.decode(idk)),sealKey=cryptic.decode(sealBits).slice(32,64),contents=await cryptic.decrypt(env.ciphertext,sealKey,sealAD);return{from:from,contents:JSON.parse(contents)}})(useUser().idk,env)),user.createSession=(async card=>{let session=await async function(user,card){let epk=await cryptic.createECDH(),init={};init.to=card.idk,init.from=user.idk.pub.toString(),init.spk=card.spk,init.epk=epk.pub,card.opk&&(init.opk=card.opk);let dh1=await cryptic.ecdh(user.idk.key,init.spk),dh2=await cryptic.ecdh(epk.key,init.to),dh3=await cryptic.ecdh(epk.key,init.spk),dh4=null;return init.opk&&(dh4=await cryptic.ecdh(epk.key,init.opk)),sessionHash(await cryptic.combine(cryptic.combine(dh1,dh2),cryptic.combine(dh3,dh4)),init)}(useUser(),card);return session.user=card.idk,session.state=await async function(session){let state={};state.DHs=await cryptic.createECDH(),state.DHr=session.init.spk;let dh=await cryptic.ecdh(state.DHs.key,state.DHr);return[state.RK,state.CKs]=await rootKDF(session.sk,dh),state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session),delete session.sk,Session(session)}),user.openSession=(async init=>{let session=await async function(user,init){let dh1=await cryptic.ecdh(user.spk.key,init.from),dh2=await cryptic.ecdh(user.idk.key,init.epk),dh3=await cryptic.ecdh(user.spk.key,init.epk),dh4=null;if(init.opk&&user.opks[init.opk]){let opk=user.opks[init.opk].toString();delete user.opks[init.opk],dh4=await cryptic.ecdh(opk,init.epk)}return sessionHash(await cryptic.combine(cryptic.combine(dh1,dh2),cryptic.combine(dh3,dh4)),init)}(useUser(),init);return session.user=init.from,session.recvFrom=useUser().idk.pub.toString(),session.state=await async function(session,spk){let state={};return state.DHs=spk,state.DHr=null,state.RK=session.sk,state.CKs=null,state.CKr=null,state.Ns=0,state.Nr=0,state.PN=0,state.MKSKIPPED={},state}(session,useUser().spk),delete session.sk,Session(session)}),user.loadSession=(async session=>Session(session)),user.save=(()=>cloneState(userState)),user}let cynops={};return cynops.createUser=(async()=>{return User(await async function(){let idk=await cryptic.createECDH(),spk=await cryptic.createECDH();return cloneState({idk:idk,spk:spk,opks:{},card:await createCard({idk:idk,spk:spk})})}())}),cynops.loadUser=(async userData=>User(userData)),cynops}"undefined"!=typeof module&&module&&module.exports&&(module.exports=Cynops);